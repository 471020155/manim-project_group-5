from manim import *
import numpy as np

class ContinuousFlowInductionWithDipoles(Scene):
    def construct(self):
        # Setup
        self.camera.background_color = "#0b132b"
        
        # ---------- Create Capacitor ----------
        plate_height = 2.5
        plate_width = 0.3
        gap = 2.5
        
        left_plate = Rectangle(
            height=plate_height, 
            width=plate_width,
            fill_color=YELLOW,
            fill_opacity=0.6,
            stroke_color=YELLOW,
            stroke_width=2
        ).shift(LEFT * (gap/2 + plate_width/2))
        
        right_plate = left_plate.copy().shift(RIGHT * (gap + plate_width))
        
        capacitor = VGroup(left_plate, right_plate)
        self.play(Create(capacitor), run_time=1)
        self.wait(0.3)
        
        # ---------- Create Circuit ----------
        # Simple U-shaped circuit
        left_wire_start = left_plate.get_left() + LEFT * 2
        right_wire_end = right_plate.get_right() + RIGHT * 2
        
        left_wire = Line(left_wire_start, left_plate.get_left(), 
                        color="#CCCCCC", stroke_width=5)
        right_wire = Line(right_plate.get_right(), right_wire_end, 
                         color="#CCCCCC", stroke_width=5)
        
        bottom_y = left_wire_start[1] - 1.5
        bottom_wire = Line(left_wire_start + DOWN*1.5, right_wire_end + DOWN*1.5,
                          color="#CCCCCC", stroke_width=5)
        
        left_vertical = Line(left_wire_start, left_wire_start + DOWN*1.5,
                           color="#CCCCCC", stroke_width=5)
        right_vertical = Line(right_wire_end, right_wire_end + DOWN*1.5,
                            color="#CCCCCC", stroke_width=5)
        
        wires = VGroup(left_wire, right_wire, left_vertical, bottom_wire, right_vertical)
        self.play(Create(wires), run_time=1.5)
        
        # ---------- Add Battery ----------
        battery_pos = bottom_wire.get_center() + DOWN * 0.4
        
        battery = VGroup(
            Rectangle(height=0.7, width=0.4, 
                     fill_color=WHITE, fill_opacity=1, 
                     stroke_color=WHITE, stroke_width=2),
            Line(UP*0.35, DOWN*0.35, color=BLACK, stroke_width=2),
            Text("+", font_size=14, color=BLACK, weight=BOLD),
            Text("−", font_size=14, color=BLACK, weight=BOLD),
        )
        battery.move_to(battery_pos)
        battery[2].move_to(battery.get_center() + LEFT*0.1 + UP*0.15)
        battery[3].move_to(battery.get_center() + LEFT*0.1 + DOWN*0.15)
        
        self.play(Create(battery), run_time=0.8)
        
        # ---------- Title ----------
        title = Text("Continuous Current Flow & Induction", color=YELLOW, font_size=24)
        title.to_edge(UP)
        self.play(Write(title))
        
        # ---------- Create DIPOLES in capacitor gap ----------
        # Create small yellow dipoles (arrows with + and -)
        num_dipoles = 5  # Number of dipoles to create
        dipoles = []  # Store dipoles for animation
        dipole_positions = []  # Store positions for dipoles
        
        # Calculate positions for dipoles (evenly spaced in gap)
        for i in range(num_dipoles):
            # Vertical position in capacitor gap
            y_pos = -plate_height/2 + (i + 0.5) * (plate_height / num_dipoles)
            
            # Horizontal position in gap (centered between plates)
            x_pos = 0  # Center of gap
            
            dipole_positions.append([x_pos, y_pos, 0])
            
            # Create dipole (arrow from positive to negative)
            dipole_arrow = Arrow(
                start=LEFT * 0.3,  # Will be positioned later
                end=RIGHT * 0.3,
                color="#FFFF00",  # Bright yellow
                stroke_width=2,
                buff=0.1,
                max_tip_length_to_length_ratio=0.25
            )
            
            # Create + and - signs
            plus_sign = Text("+", font_size=12, color="#FF5555", weight=BOLD)
            minus_sign = Text("-", font_size=12, color="#5555FF", weight=BOLD)
            
            # Position signs at ends of arrow
            plus_sign.next_to(dipole_arrow.get_end(), RIGHT, buff=0.08)
            minus_sign.next_to(dipole_arrow.get_start(), LEFT, buff=0.08)
            
            # Create dipole group
            dipole_group = VGroup(dipole_arrow, plus_sign, minus_sign)
            dipole_group.move_to([x_pos, y_pos, 0])
            dipoles.append(dipole_group)
            
            # Initially dipoles are small (collapsed)
            dipole_group.scale(0.3)  # Start very small
            dipole_group.set_opacity(0.3)  # Semi-transparent
        
        # Add dipoles to scene
        dipoles_group = VGroup(*dipoles)
        self.play(FadeIn(dipoles_group), run_time=1)
        
        # ---------- Create FLOW SYSTEM ----------
        # Define paths for continuous flow
        positive_path = VMobject()
        positive_points = [
            battery[0].get_right() + RIGHT*0.1,
            battery[0].get_right() + RIGHT*0.8,
            right_vertical.get_end(),
            right_wire_end,
            right_plate.get_right(),
            right_plate.get_center()
        ]
        positive_path.set_points_smoothly(positive_points)
        
        electron_path = VMobject()
        electron_points = [
            left_plate.get_center(),
            left_plate.get_left(),
            left_wire_start,
            left_vertical.get_end(),
            battery[0].get_left() + LEFT*0.8,
            battery[0].get_left() + UP*0.1
        ]
        electron_path.set_points_smoothly(electron_points)
        
        # ---------- CREATE CONTINUOUS FLOW ----------
        # Create charge positions for accumulation
        total_charges_to_accumulate = 8
        positive_positions = []
        negative_positions = []
        
        rows = 4
        cols = 2
        for row in range(rows):
            for col in range(cols):
                if len(positive_positions) >= total_charges_to_accumulate:
                    break
                y = -1 + row * 0.5
                x_offset = 0.08 + col * 0.05
                positive_positions.append(right_plate.get_left() + RIGHT*x_offset + UP*y)
                negative_positions.append(left_plate.get_right() + LEFT*x_offset + UP*y)
        
        # Track accumulated charges
        accumulated_positive = []
        accumulated_negative = []
        
        # Create initial flowing charges
        num_concurrent_charges = 4
        positive_flow = []  # Moving positive charges
        electron_flow = []  # Moving electrons
        
        for i in range(num_concurrent_charges):
            # Positive charge
            pos_charge = Dot(
                battery[0].get_right() + RIGHT*0.1 + UP*(i*0.1 - 0.15),
                color="#FFAA00",
                radius=0.04,
                fill_opacity=0.9
            )
            positive_flow.append(pos_charge)
            self.add(pos_charge)
            
            # Electron
            elec_charge = Dot(
                left_plate.get_center() + UP*(i*0.1 - 0.15),
                color="#00AAFF",
                radius=0.04,
                fill_opacity=0.9
            )
            electron_flow.append(elec_charge)
            self.add(elec_charge)
        
        # ---------- ELECTRIC FIELD ARROWS THAT INCREASE IN NUMBER ----------
        max_field_arrows = 8
        field_arrows_group = VGroup()
        
        # Store arrow positions
        arrow_positions = []
        for i in range(max_field_arrows):
            y = -1.2 + (i / (max_field_arrows - 1)) * 2.4 if max_field_arrows > 1 else 0
            start = right_plate.get_left() + LEFT*0.08 + UP*y
            end = left_plate.get_right() + RIGHT*0.08 + UP*y
            arrow_positions.append((start, end))
        
        self.add(field_arrows_group)
        
        # ---------- MAIN ANIMATION LOOP ----------
        accumulated_count = 0
        
        for charge_num in range(total_charges_to_accumulate):
            # Animate current flow
            animations = []
            
            for i in range(num_concurrent_charges):
                if positive_flow[i] is not None:
                    animations.append(
                        MoveAlongPath(
                            positive_flow[i],
                            positive_path,
                            rate_func=linear,
                            run_time=1.8
                        )
                    )
                
                if electron_flow[i] is not None:
                    animations.append(
                        MoveAlongPath(
                            electron_flow[i],
                            electron_path,
                            rate_func=linear,
                            run_time=1.8
                        )
                    )
            
            if animations:
                self.play(*animations, run_time=1.8)
            
            # Process accumulation
            if accumulated_count < total_charges_to_accumulate:
                # Create accumulated charges
                pos_dot = Dot(
                    positive_positions[accumulated_count],
                    color="#FF5555",
                    radius=0.06,
                    fill_opacity=1
                )
                plus_sign = Text("+", font_size=16, color="#FF5555", weight=BOLD)
                plus_sign.move_to(pos_dot.get_center())
                pos_group = VGroup(pos_dot, plus_sign)
                
                neg_dot = Dot(
                    negative_positions[accumulated_count],
                    color="#5555FF",
                    radius=0.06,
                    fill_opacity=1
                )
                minus_sign = Text("−", font_size=16, color="#5555FF", weight=BOLD)
                minus_sign.move_to(neg_dot.get_center())
                neg_group = VGroup(neg_dot, minus_sign)
                
                # Find which charge to accumulate
                for i in range(num_concurrent_charges):
                    if (positive_flow[i] is not None and 
                        positive_flow[i].get_center()[0] > right_plate.get_left()[0]):
                        
                        # Animate accumulation
                        self.play(
                            FadeOut(positive_flow[i]),
                            FadeIn(pos_group),
                            FadeIn(neg_group),
                            run_time=0.3
                        )
                        
                        accumulated_positive.append(pos_group)
                        accumulated_negative.append(neg_group)
                        accumulated_count += 1
                        
                        # Update charge count
                        count_text = Text(f" ", font_size=20, color=WHITE)
                        count_text.next_to(capacitor, DOWN)
                        
                        if accumulated_count == 1:
                            self.play(Write(count_text))
                        else:
                            for mob in self.mobjects:
                                if isinstance(mob, Text) and "Q =" in mob.text:
                                    self.play(Transform(mob, count_text))
                                    break
                        
                        # ========== ANIMATE DIPOLES STRETCHING ==========
                        # Calculate stretch factor based on accumulated charges
                        stretch_factor = 0.3 + (accumulated_count / total_charges_to_accumulate) * 1.2
                        opacity_factor = 0.3 + (accumulated_count / total_charges_to_accumulate) * 0.7
                        
                        # Create new stretched dipoles
                        stretched_dipoles = []
                        for j, pos in enumerate(dipole_positions):
                            # Create new dipole with increased size
                            new_dipole_arrow = Arrow(
                                start=LEFT * (0.3 * stretch_factor),
                                end=RIGHT * (0.3 * stretch_factor),
                                color="#FFFF00",
                                stroke_width=1 + accumulated_count * 0.3,  # Thicker with more charge
                                buff=0.1,
                                max_tip_length_to_length_ratio=0.25
                            )
                            
                            new_plus = Text(" ", font_size=12 + accumulated_count, 
                                          color="#FF5555", weight=BOLD)
                            new_minus = Text(" ", font_size=12 + accumulated_count, 
                                           color="#5555FF", weight=BOLD)
                            
                            new_plus.next_to(new_dipole_arrow.get_end(), RIGHT, buff=0.08)
                            new_minus.next_to(new_dipole_arrow.get_start(), LEFT, buff=0.08)
                            
                            new_dipole = VGroup(new_dipole_arrow, new_plus, new_minus)
                            new_dipole.move_to(pos)
                            new_dipole.set_opacity(opacity_factor)
                            stretched_dipoles.append(new_dipole)
                        
                        # Animate dipoles stretching
                        self.play(
                            *[Transform(dipoles[k], stretched_dipoles[k]) 
                              for k in range(len(dipoles))],
                            run_time=0.5
                        )
                        
                        # Update dipoles list
                        for k in range(len(dipoles)):
                            dipoles[k] = stretched_dipoles[k]
                        
                        # INCREASE ELECTRIC FIELD ARROWS
                        if accumulated_count >= 2:
                            arrows_to_show = int((accumulated_count / total_charges_to_accumulate) * max_field_arrows)
                            arrows_to_show = max(1, arrows_to_show)
                            
                            new_field_arrows = VGroup()
                            for j in range(arrows_to_show):
                                start, end = arrow_positions[j]
                                progress = accumulated_count / total_charges_to_accumulate
                                arrow_strength = 0.5 + progress * 3.5
                                arrow_opacity = 0.3 + progress * 0.7
                                
                                arrow = Arrow(
                                    start,
                                    end,
                                    color="#EC7063",
                                    stroke_width=arrow_strength,
                                    max_tip_length_to_length_ratio=0.08,
                                    fill_opacity=arrow_opacity
                                )
                                new_field_arrows.add(arrow)
                            
                            if len(field_arrows_group) == 0:
                                field_arrows_group = new_field_arrows
                                self.add(field_arrows_group)
                                self.play(
                                    Create(field_arrows_group),
                                    run_time=0.5
                                )
                            else:
                                self.play(
                                    Transform(field_arrows_group, new_field_arrows),
                                    run_time=0.5
                                )
                        
                        # Reset charges for continuous flow
                        positive_flow[i] = Dot(
                            battery[0].get_right() + RIGHT*0.1 + UP*(i*0.1 - 0.15),
                            color="#FFAA00",
                            radius=0.04,
                            fill_opacity=0.9
                        )
                        self.add(positive_flow[i])
                        
                        if electron_flow[i] is not None:
                            self.remove(electron_flow[i])
                        
                        electron_flow[i] = Dot(
                            left_plate.get_center() + UP*(i*0.1 - 0.15),
                            color="#00AAFF",
                            radius=0.04,
                            fill_opacity=0.9
                        )
                        self.add(electron_flow[i])
                        
                        break
            
            if charge_num < total_charges_to_accumulate - 1:
                self.wait(0.2)
        
        # ---------- CONTINUE FLOW ----------
        for _ in range(2):
            animations = []
            for i in range(num_concurrent_charges):
                if positive_flow[i] is not None:
                    animations.append(
                        MoveAlongPath(
                            positive_flow[i],
                            positive_path,
                            rate_func=linear,
                            run_time=1.5
                        )
                    )
                if electron_flow[i] is not None:
                    animations.append(
                        MoveAlongPath(
                            electron_flow[i],
                            electron_path,
                            rate_func=linear,
                            run_time=1.5
                        )
                    )
            
            if animations:
                self.play(*animations, run_time=1.5)
            
            for i in range(num_concurrent_charges):
                if (positive_flow[i] is not None and 
                    positive_flow[i].get_center()[0] > right_plate.get_left()[0]):
                    self.remove(positive_flow[i])
                    positive_flow[i] = Dot(
                        battery[0].get_right() + RIGHT*0.1 + UP*(i*0.1 - 0.15),
                        color="#FFAA00",
                        radius=0.04,
                        fill_opacity=0.9
                    )
                    self.add(positive_flow[i])
                
                if (electron_flow[i] is not None and 
                    electron_flow[i].get_center()[0] < battery[0].get_left()[0] + 0.3):
                    self.remove(electron_flow[i])
                    electron_flow[i] = Dot(
                        left_plate.get_center() + UP*(i*0.1 - 0.15),
                        color="#00AAFF",
                        radius=0.04,
                        fill_opacity=0.9
                    )
                    self.add(electron_flow[i])
            
            self.wait(0.2)
        
        # ---------- GRADUALLY STOP CURRENT ----------
        current_label = Text(" ", color="#FFAA00", font_size=18)
        current_label.next_to(bottom_wire, DOWN)
        self.play(Write(current_label))
        
        for i in range(num_concurrent_charges):
            if positive_flow[i] is not None:
                self.play(FadeOut(positive_flow[i]), run_time=0.3)
            if electron_flow[i] is not None:
                self.play(FadeOut(electron_flow[i]), run_time=0.3)
            self.wait(0.1)
        
        self.remove(current_label)
        
        # ---------- FINAL STATE ----------
        final_title = Text("CAPACITOR FULLY CHARGED", color=YELLOW, font_size=26, weight=BOLD)
        final_title.to_edge(UP)
        
        # Add dipoles label
        dipoles_label = Text(f" ", 
                           color="#FFFF00", font_size=18)
        dipoles_label.next_to(dipoles_group, DOWN)
        
        summary = VGroup(
            Text(f" ", color="#FF5555", font_size=20),
            Text(f" ", color="#5555FF", font_size=20),
            Text("Current: 0", color="#FFAA00", font_size=20),
            Text(f" ", color="#FFFF00", font_size=20),
        )
        summary.arrange(DOWN, aligned_edge=LEFT, buff=0.15)
        summary.to_edge(RIGHT).shift(DOWN*0.5)
        
        self.play(
            Transform(title, final_title),
            Write(dipoles_label),
            Write(summary),
            run_time=1.5
        )
        
        # ---------- FINAL ELECTRIC FIELD ----------
        final_field_arrows = VGroup()
        for start, end in arrow_positions:
            arrow = Arrow(
                start,
                end,
                color="#00FF88",
                stroke_width=4.0,
                max_tip_length_to_length_ratio=0.08,
                fill_opacity=1.0
            )
            final_field_arrows.add(arrow)
        
        self.play(
            Transform(field_arrows_group, final_field_arrows),
            run_time=1
        )
        
        field_label = Text(f" ", 
                          color="#00FF88", font_size=18)
        field_label.next_to(field_arrows_group, UP)
        self.play(Write(field_label))
        
        # ---------- HIGHLIGHT DIPOLES ----------
        # Make dipoles pulse to show they're fully stretched
        for _ in range(2):
            self.play(
                *[dipole.animate.set_opacity(1).scale(1.1) for dipole in dipoles],
                run_time=0.5
            )
            self.play(
                *[dipole.animate.set_opacity(0.7).scale(1/1.1) for dipole in dipoles],
                run_time=0.5
            )
        
        self.wait(3)
